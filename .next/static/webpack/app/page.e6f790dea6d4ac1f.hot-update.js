"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/websocket-client.ts":
/*!*********************************!*\
  !*** ./lib/websocket-client.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DevTeaWebSocketClient: function() { return /* binding */ DevTeaWebSocketClient; }\n/* harmony export */ });\nclass DevTeaWebSocketClient {\n    async connect() {\n        console.log(\"Connecting WebSocket client...\");\n        this.isConnected = false;\n        this.retryCount = 0;\n        // Register user with retry logic\n        const result = await this.sendMessageWithRetry(\"register\", {\n            userId: this.userId,\n            username: this.username\n        });\n        if (result.success) {\n            var _result_data;\n            this.isConnected = true;\n            // Restore joined rooms from registration response\n            if ((_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.joinedRooms) {\n                this.persistedRooms = new Set(result.data.joinedRooms);\n                console.log(\"Restored rooms:\", Array.from(this.persistedRooms));\n            }\n            // Start polling for updates\n            this.startPolling();\n            this.onMessage({\n                type: \"connected\",\n                data: {\n                    joinedRooms: Array.from(this.persistedRooms)\n                }\n            });\n            console.log(\"WebSocket client connected successfully\");\n        } else {\n            console.error(\"Failed to register user:\", result.error);\n            this.onMessage({\n                type: \"connection_failed\",\n                data: {\n                    error: result.error\n                }\n            });\n        }\n    }\n    async sendMessage(type, data) {\n        if (!this.isConnected && type !== \"register\") {\n            console.warn(\"Client not connected, attempting to reconnect...\");\n            await this.connect();\n        }\n        try {\n            console.log(\"Sending message: \".concat(type), data);\n            // Add timeout to the fetch request\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 10000) // 10 second timeout\n            ;\n            const response = await fetch(\"/api/websocket\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    type,\n                    data,\n                    userId: this.userId\n                }),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n            }\n            const result = await response.json();\n            console.log(\"Response for \".concat(type, \":\"), result);\n            if (result.success && result.type) {\n                this.onMessage(result);\n            }\n            // Reset retry count on successful request\n            this.retryCount = 0;\n            return result;\n        } catch (error) {\n            console.error(\"WebSocket send error:\", error);\n            // Handle specific error types\n            if (error.name === \"AbortError\") {\n                return {\n                    success: false,\n                    error: \"Request timeout\"\n                };\n            }\n            if (error.message.includes(\"ERR_INTERNET_DISCONNECTED\") || error.message.includes(\"ERR_NETWORK\") || error.message.includes(\"Failed to fetch\")) {\n                this.isConnected = false;\n                this.onMessage({\n                    type: \"connection_lost\",\n                    data: {\n                        error: error.message\n                    }\n                });\n                return {\n                    success: false,\n                    error: \"Network connection lost\"\n                };\n            }\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async sendMessageWithRetry(type, data) {\n        let maxRetries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;\n        for(let attempt = 1; attempt <= maxRetries; attempt++){\n            var _result_error, _result_error1, _result_error2;\n            console.log(\"Attempt \".concat(attempt, \"/\").concat(maxRetries, \" for \").concat(type));\n            const result = await this.sendMessage(type, data);\n            if (result.success) {\n                return result;\n            }\n            // If it's a network error and we have retries left, wait and try again\n            if (attempt < maxRetries && (((_result_error = result.error) === null || _result_error === void 0 ? void 0 : _result_error.includes(\"Network\")) || ((_result_error1 = result.error) === null || _result_error1 === void 0 ? void 0 : _result_error1.includes(\"timeout\")) || ((_result_error2 = result.error) === null || _result_error2 === void 0 ? void 0 : _result_error2.includes(\"disconnected\")))) {\n                const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000) // Exponential backoff, max 5s\n                ;\n                console.log(\"Retrying in \".concat(delay, \"ms...\"));\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n                continue;\n            }\n            return result;\n        }\n        return {\n            success: false,\n            error: \"Max retries exceeded\"\n        };\n    }\n    async joinRoom(roomId) {\n        console.log(\"Joining room: \".concat(roomId));\n        this.currentRoom = roomId;\n        this.currentContext = {\n            type: \"room\",\n            id: roomId\n        };\n        this.persistedRooms.add(roomId);\n        return this.sendMessageWithRetry(\"join_room\", {\n            roomId\n        });\n    }\n    async leaveRoom(roomId) {\n        console.log(\"Leaving room: \".concat(roomId));\n        const result = await this.sendMessageWithRetry(\"leave_room\", {\n            roomId\n        });\n        if (result.success) {\n            this.persistedRooms.delete(roomId);\n            if (this.currentRoom === roomId) {\n                this.currentRoom = null;\n                this.currentContext = null;\n            }\n        }\n        return result;\n    }\n    async searchRooms(query) {\n        return this.sendMessageWithRetry(\"search_rooms\", {\n            query\n        });\n    }\n    async createRoom(name, description) {\n        var _result_data;\n        const result = await this.sendMessageWithRetry(\"create_room\", {\n            name,\n            description\n        });\n        if (result.success && ((_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.id)) {\n            this.persistedRooms.add(result.data.id);\n        }\n        return result;\n    }\n    async getRooms() {\n        return this.sendMessageWithRetry(\"get_rooms\", {});\n    }\n    async getJoinedRooms() {\n        return this.sendMessageWithRetry(\"get_joined_rooms\", {});\n    }\n    async getRoomMembers(roomId) {\n        return this.sendMessageWithRetry(\"get_room_members\", {\n            roomId\n        });\n    }\n    async sendChatMessage(content, type, roomId, recipientId) {\n        console.log(\"=== WEBSOCKET CLIENT: Sending chat message ===\");\n        console.log(\"Type:\", type);\n        console.log(\"Room ID:\", roomId);\n        console.log(\"Recipient ID:\", recipientId);\n        console.log(\"Content:\", content);\n        // Add this validation to ensure we're sending to the correct room\n        if (type === \"room\" && !roomId) {\n            console.error(\"Attempted to send room message without roomId\");\n            return {\n                success: false,\n                error: \"Missing roomId for room message\"\n            };\n        }\n        if (type === \"dm\" && !recipientId) {\n            console.error(\"Attempted to send DM without recipientId\");\n            return {\n                success: false,\n                error: \"Missing recipientId for DM\"\n            };\n        }\n        const messageData = {\n            username: this.username,\n            content,\n            type,\n            roomId,\n            recipientId\n        };\n        console.log(\"Sending message data:\", messageData);\n        return this.sendMessageWithRetry(\"send_message\", messageData);\n    }\n    async getMessages(type, roomId, recipientId) {\n        console.log(\"Getting messages for \".concat(type, \":\"), {\n            roomId,\n            recipientId\n        });\n        this.currentContext = {\n            type,\n            id: roomId || recipientId || \"\"\n        };\n        return this.sendMessageWithRetry(\"get_messages\", {\n            type,\n            roomId,\n            recipientId\n        });\n    }\n    async editMessage(messageId, content, roomId, recipientId) {\n        return this.sendMessageWithRetry(\"edit_message\", {\n            messageId,\n            content,\n            roomId,\n            recipientId\n        });\n    }\n    async deleteMessage(messageId, roomId, recipientId) {\n        return this.sendMessageWithRetry(\"delete_message\", {\n            messageId,\n            roomId,\n            recipientId\n        });\n    }\n    async getOnlineUsers() {\n        return this.sendMessage(\"get_online_users\", {}) // Don't retry this as it's called frequently\n        ;\n    }\n    getPersistedRooms() {\n        return Array.from(this.persistedRooms);\n    }\n    startPolling() {\n        // Poll for updates every 3 seconds (increased from 2s to reduce load)\n        this.pollInterval = setInterval(async ()=>{\n            if (!this.isConnected) {\n                console.log(\"Skipping poll - not connected\");\n                return;\n            }\n            try {\n                // Get latest messages for current context\n                if (this.currentContext) {\n                    if (this.currentContext.type === \"room\") {\n                        var _result_error;\n                        const result = await this.sendMessage(\"get_messages\", {\n                            type: \"room\",\n                            roomId: this.currentContext.id\n                        });\n                        if (result.success && result.type === \"room_messages\") {\n                            this.onMessage({\n                                type: \"room_messages_update\",\n                                data: result.data\n                            });\n                        } else if (!result.success && ((_result_error = result.error) === null || _result_error === void 0 ? void 0 : _result_error.includes(\"Network\"))) {\n                            console.log(\"Network error during polling, will retry on next interval\");\n                        }\n                    } else if (this.currentContext.type === \"dm\") {\n                        const result = await this.sendMessage(\"get_messages\", {\n                            type: \"dm\",\n                            recipientId: this.currentContext.id\n                        });\n                        if (result.success && result.type === \"dm_messages\") {\n                            this.onMessage({\n                                type: \"dm_messages_update\",\n                                data: result.data\n                            });\n                        }\n                    }\n                }\n                // Get online users periodically (less frequently)\n                if (Math.random() < 0.3) {\n                    // Only 30% of the time to reduce load\n                    await this.getOnlineUsers();\n                }\n            } catch (error) {\n                console.error(\"Polling error:\", error);\n            // Don't mark as disconnected for polling errors\n            }\n        }, 3000);\n    }\n    async reconnect() {\n        console.log(\"Attempting to reconnect...\");\n        this.disconnect();\n        await new Promise((resolve)=>setTimeout(resolve, 1000)) // Wait 1 second\n        ;\n        await this.connect();\n    }\n    disconnect() {\n        console.log(\"Disconnecting WebSocket client...\");\n        this.isConnected = false;\n        if (this.pollInterval) {\n            clearInterval(this.pollInterval);\n            this.pollInterval = null;\n        }\n        this.currentRoom = null;\n        this.currentContext = null;\n        this.onMessage({\n            type: \"disconnected\"\n        });\n    }\n    constructor(userId, username, onMessage){\n        this.pollInterval = null;\n        this.currentRoom = null;\n        this.currentContext = null;\n        this.persistedRooms = new Set();\n        this.isConnected = false;\n        this.retryCount = 0;\n        this.maxRetries = 3;\n        this.userId = userId;\n        this.username = username;\n        this.onMessage = onMessage;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi93ZWJzb2NrZXQtY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFvQk8sTUFBTUE7SUFrQlgsTUFBTUMsVUFBVTtRQUNkQyxRQUFRQyxHQUFHLENBQUM7UUFDWixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUVsQixpQ0FBaUM7UUFDakMsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ0Msb0JBQW9CLENBQUMsWUFBWTtZQUFFQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUFFQyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtRQUFDO1FBRTFHLElBQUlILE9BQU9JLE9BQU8sRUFBRTtnQkFHZEo7WUFGSixJQUFJLENBQUNGLFdBQVcsR0FBRztZQUNuQixrREFBa0Q7WUFDbEQsS0FBSUUsZUFBQUEsT0FBT0ssSUFBSSxjQUFYTCxtQ0FBQUEsYUFBYU0sV0FBVyxFQUFFO2dCQUM1QixJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJQyxJQUFJUixPQUFPSyxJQUFJLENBQUNDLFdBQVc7Z0JBQ3JEVixRQUFRQyxHQUFHLENBQUMsbUJBQW1CWSxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDSCxjQUFjO1lBQy9EO1lBRUEsNEJBQTRCO1lBQzVCLElBQUksQ0FBQ0ksWUFBWTtZQUNqQixJQUFJLENBQUNDLFNBQVMsQ0FBQztnQkFBRUMsTUFBTTtnQkFBYVIsTUFBTTtvQkFBRUMsYUFBYUcsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ0gsY0FBYztnQkFBRTtZQUFFO1lBQzNGWCxRQUFRQyxHQUFHLENBQUM7UUFDZCxPQUFPO1lBQ0xELFFBQVFrQixLQUFLLENBQUMsNEJBQTRCZCxPQUFPYyxLQUFLO1lBQ3RELElBQUksQ0FBQ0YsU0FBUyxDQUFDO2dCQUFFQyxNQUFNO2dCQUFxQlIsTUFBTTtvQkFBRVMsT0FBT2QsT0FBT2MsS0FBSztnQkFBQztZQUFFO1FBQzVFO0lBQ0Y7SUFFQSxNQUFNQyxZ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Oi8vX05fRS8uL2xpYi93ZWJzb2NrZXQtY2xpZW50LnRzPzcwNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICBpZDogc3RyaW5nXG4gIHVzZXI6IHN0cmluZ1xuICBjb250ZW50OiBzdHJpbmdcbiAgdGltZXN0YW1wOiBudW1iZXJcbiAgZWRpdGVkPzogYm9vbGVhblxuICByb29tSWQ/OiBzdHJpbmdcbiAgcmVjaXBpZW50SWQ/OiBzdHJpbmdcbiAgdHlwZTogXCJyb29tXCIgfCBcImRtXCJcbn1cblxuaW50ZXJmYWNlIFJvb20ge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIG1lbWJlckNvdW50OiBudW1iZXJcbiAgaXNNZW1iZXI6IGJvb2xlYW5cbiAgaXNKb2luZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIERldlRlYVdlYlNvY2tldENsaWVudCB7XG4gIHByaXZhdGUgdXNlcklkOiBzdHJpbmdcbiAgcHJpdmF0ZSB1c2VybmFtZTogc3RyaW5nXG4gIHByaXZhdGUgb25NZXNzYWdlOiAobWVzc2FnZTogYW55KSA9PiB2b2lkXG4gIHByaXZhdGUgcG9sbEludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgY3VycmVudFJvb206IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgY3VycmVudENvbnRleHQ6IHsgdHlwZTogXCJyb29tXCIgfCBcImRtXCI7IGlkOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgcGVyc2lzdGVkUm9vbXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG4gIHByaXZhdGUgaXNDb25uZWN0ZWQgPSBmYWxzZVxuICBwcml2YXRlIHJldHJ5Q291bnQgPSAwXG4gIHByaXZhdGUgbWF4UmV0cmllcyA9IDNcblxuICBjb25zdHJ1Y3Rvcih1c2VySWQ6IHN0cmluZywgdXNlcm5hbWU6IHN0cmluZywgb25NZXNzYWdlOiAobWVzc2FnZTogYW55KSA9PiB2b2lkKSB7XG4gICAgdGhpcy51c2VySWQgPSB1c2VySWRcbiAgICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWVcbiAgICB0aGlzLm9uTWVzc2FnZSA9IG9uTWVzc2FnZVxuICB9XG5cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RpbmcgV2ViU29ja2V0IGNsaWVudC4uLlwiKVxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMucmV0cnlDb3VudCA9IDBcblxuICAgIC8vIFJlZ2lzdGVyIHVzZXIgd2l0aCByZXRyeSBsb2dpY1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VXaXRoUmV0cnkoXCJyZWdpc3RlclwiLCB7IHVzZXJJZDogdGhpcy51c2VySWQsIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lIH0pXG5cbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlXG4gICAgICAvLyBSZXN0b3JlIGpvaW5lZCByb29tcyBmcm9tIHJlZ2lzdHJhdGlvbiByZXNwb25zZVxuICAgICAgaWYgKHJlc3VsdC5kYXRhPy5qb2luZWRSb29tcykge1xuICAgICAgICB0aGlzLnBlcnNpc3RlZFJvb21zID0gbmV3IFNldChyZXN1bHQuZGF0YS5qb2luZWRSb29tcylcbiAgICAgICAgY29uc29sZS5sb2coXCJSZXN0b3JlZCByb29tczpcIiwgQXJyYXkuZnJvbSh0aGlzLnBlcnNpc3RlZFJvb21zKSlcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgcG9sbGluZyBmb3IgdXBkYXRlc1xuICAgICAgdGhpcy5zdGFydFBvbGxpbmcoKVxuICAgICAgdGhpcy5vbk1lc3NhZ2UoeyB0eXBlOiBcImNvbm5lY3RlZFwiLCBkYXRhOiB7IGpvaW5lZFJvb21zOiBBcnJheS5mcm9tKHRoaXMucGVyc2lzdGVkUm9vbXMpIH0gfSlcbiAgICAgIGNvbnNvbGUubG9nKFwiV2ViU29ja2V0IGNsaWVudCBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5XCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmVnaXN0ZXIgdXNlcjpcIiwgcmVzdWx0LmVycm9yKVxuICAgICAgdGhpcy5vbk1lc3NhZ2UoeyB0eXBlOiBcImNvbm5lY3Rpb25fZmFpbGVkXCIsIGRhdGE6IHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9IH0pXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2VuZE1lc3NhZ2UodHlwZTogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQgJiYgdHlwZSAhPT0gXCJyZWdpc3RlclwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDbGllbnQgbm90IGNvbm5lY3RlZCwgYXR0ZW1wdGluZyB0byByZWNvbm5lY3QuLi5cIilcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBTZW5kaW5nIG1lc3NhZ2U6ICR7dHlwZX1gLCBkYXRhKVxuXG4gICAgICAvLyBBZGQgdGltZW91dCB0byB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDEwMDAwKSAvLyAxMCBzZWNvbmQgdGltZW91dFxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS93ZWJzb2NrZXRcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgZGF0YSwgdXNlcklkOiB0aGlzLnVzZXJJZCB9KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pXG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc29sZS5sb2coYFJlc3BvbnNlIGZvciAke3R5cGV9OmAsIHJlc3VsdClcblxuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC50eXBlKSB7XG4gICAgICAgIHRoaXMub25NZXNzYWdlKHJlc3VsdClcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgcmV0cnkgY291bnQgb24gc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICB0aGlzLnJldHJ5Q291bnQgPSAwXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJXZWJTb2NrZXQgc2VuZCBlcnJvcjpcIiwgZXJyb3IpXG5cbiAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBlcnJvciB0eXBlc1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJSZXF1ZXN0IHRpbWVvdXRcIiB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkVSUl9JTlRFUk5FVF9ESVNDT05ORUNURURcIikgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkVSUl9ORVRXT1JLXCIpIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIilcbiAgICAgICkge1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UoeyB0eXBlOiBcImNvbm5lY3Rpb25fbG9zdFwiLCBkYXRhOiB7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0gfSlcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIk5ldHdvcmsgY29ubmVjdGlvbiBsb3N0XCIgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNlbmRNZXNzYWdlV2l0aFJldHJ5KHR5cGU6IHN0cmluZywgZGF0YTogYW55LCBtYXhSZXRyaWVzID0gMykge1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgY29uc29sZS5sb2coYEF0dGVtcHQgJHthdHRlbXB0fS8ke21heFJldHJpZXN9IGZvciAke3R5cGV9YClcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZSh0eXBlLCBkYXRhKVxuXG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGEgbmV0d29yayBlcnJvciBhbmQgd2UgaGF2ZSByZXRyaWVzIGxlZnQsIHdhaXQgYW5kIHRyeSBhZ2FpblxuICAgICAgaWYgKFxuICAgICAgICBhdHRlbXB0IDwgbWF4UmV0cmllcyAmJlxuICAgICAgICAocmVzdWx0LmVycm9yPy5pbmNsdWRlcyhcIk5ldHdvcmtcIikgfHxcbiAgICAgICAgICByZXN1bHQuZXJyb3I/LmluY2x1ZGVzKFwidGltZW91dFwiKSB8fFxuICAgICAgICAgIHJlc3VsdC5lcnJvcj8uaW5jbHVkZXMoXCJkaXNjb25uZWN0ZWRcIikpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbigxMDAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpLCA1MDAwKSAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmLCBtYXggNXNcbiAgICAgICAgY29uc29sZS5sb2coYFJldHJ5aW5nIGluICR7ZGVsYXl9bXMuLi5gKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiTWF4IHJldHJpZXMgZXhjZWVkZWRcIiB9XG4gIH1cblxuICBhc3luYyBqb2luUm9vbShyb29tSWQ6IHN0cmluZykge1xuICAgIGNvbnNvbGUubG9nKGBKb2luaW5nIHJvb206ICR7cm9vbUlkfWApXG4gICAgdGhpcy5jdXJyZW50Um9vbSA9IHJvb21JZFxuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSB7IHR5cGU6IFwicm9vbVwiLCBpZDogcm9vbUlkIH1cbiAgICB0aGlzLnBlcnNpc3RlZFJvb21zLmFkZChyb29tSWQpXG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2VXaXRoUmV0cnkoXCJqb2luX3Jvb21cIiwgeyByb29tSWQgfSlcbiAgfVxuXG4gIGFzeW5jIGxlYXZlUm9vbShyb29tSWQ6IHN0cmluZykge1xuICAgIGNvbnNvbGUubG9nKGBMZWF2aW5nIHJvb206ICR7cm9vbUlkfWApXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVdpdGhSZXRyeShcImxlYXZlX3Jvb21cIiwgeyByb29tSWQgfSlcblxuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgdGhpcy5wZXJzaXN0ZWRSb29tcy5kZWxldGUocm9vbUlkKVxuICAgICAgaWYgKHRoaXMuY3VycmVudFJvb20gPT09IHJvb21JZCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRSb29tID0gbnVsbFxuICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGFzeW5jIHNlYXJjaFJvb21zKHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZVdpdGhSZXRyeShcInNlYXJjaF9yb29tc1wiLCB7IHF1ZXJ5IH0pXG4gIH1cblxuICBhc3luYyBjcmVhdGVSb29tKG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VXaXRoUmV0cnkoXCJjcmVhdGVfcm9vbVwiLCB7IG5hbWUsIGRlc2NyaXB0aW9uIH0pXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhPy5pZCkge1xuICAgICAgdGhpcy5wZXJzaXN0ZWRSb29tcy5hZGQocmVzdWx0LmRhdGEuaWQpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGFzeW5jIGdldFJvb21zKCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlV2l0aFJldHJ5KFwiZ2V0X3Jvb21zXCIsIHt9KVxuICB9XG5cbiAgYXN5bmMgZ2V0Sm9pbmVkUm9vbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2VXaXRoUmV0cnkoXCJnZXRfam9pbmVkX3Jvb21zXCIsIHt9KVxuICB9XG5cbiAgYXN5bmMgZ2V0Um9vbU1lbWJlcnMocm9vbUlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZVdpdGhSZXRyeShcImdldF9yb29tX21lbWJlcnNcIiwgeyByb29tSWQgfSlcbiAgfVxuXG4gIGFzeW5jIHNlbmRDaGF0TWVzc2FnZShjb250ZW50OiBzdHJpbmcsIHR5cGU6IFwicm9vbVwiIHwgXCJkbVwiLCByb29tSWQ/OiBzdHJpbmcsIHJlY2lwaWVudElkPzogc3RyaW5nKSB7XG4gICAgY29uc29sZS5sb2coYD09PSBXRUJTT0NLRVQgQ0xJRU5UOiBTZW5kaW5nIGNoYXQgbWVzc2FnZSA9PT1gKVxuICAgIGNvbnNvbGUubG9nKFwiVHlwZTpcIiwgdHlwZSlcbiAgICBjb25zb2xlLmxvZyhcIlJvb20gSUQ6XCIsIHJvb21JZClcbiAgICBjb25zb2xlLmxvZyhcIlJlY2lwaWVudCBJRDpcIiwgcmVjaXBpZW50SWQpXG4gICAgY29uc29sZS5sb2coXCJDb250ZW50OlwiLCBjb250ZW50KVxuXG4gICAgLy8gQWRkIHRoaXMgdmFsaWRhdGlvbiB0byBlbnN1cmUgd2UncmUgc2VuZGluZyB0byB0aGUgY29ycmVjdCByb29tXG4gICAgaWYgKHR5cGUgPT09IFwicm9vbVwiICYmICFyb29tSWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdHRlbXB0ZWQgdG8gc2VuZCByb29tIG1lc3NhZ2Ugd2l0aG91dCByb29tSWRcIilcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJNaXNzaW5nIHJvb21JZCBmb3Igcm9vbSBtZXNzYWdlXCIgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBcImRtXCIgJiYgIXJlY2lwaWVudElkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXR0ZW1wdGVkIHRvIHNlbmQgRE0gd2l0aG91dCByZWNpcGllbnRJZFwiKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIk1pc3NpbmcgcmVjaXBpZW50SWQgZm9yIERNXCIgfVxuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0ge1xuICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICBjb250ZW50LFxuICAgICAgdHlwZSxcbiAgICAgIHJvb21JZCxcbiAgICAgIHJlY2lwaWVudElkLFxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiU2VuZGluZyBtZXNzYWdlIGRhdGE6XCIsIG1lc3NhZ2VEYXRhKVxuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlV2l0aFJldHJ5KFwic2VuZF9tZXNzYWdlXCIsIG1lc3NhZ2VEYXRhKVxuICB9XG5cbiAgYXN5bmMgZ2V0TWVzc2FnZXModHlwZTogXCJyb29tXCIgfCBcImRtXCIsIHJvb21JZD86IHN0cmluZywgcmVjaXBpZW50SWQ/OiBzdHJpbmcpIHtcbiAgICBjb25zb2xlLmxvZyhgR2V0dGluZyBtZXNzYWdlcyBmb3IgJHt0eXBlfTpgLCB7IHJvb21JZCwgcmVjaXBpZW50SWQgfSlcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0geyB0eXBlLCBpZDogcm9vbUlkIHx8IHJlY2lwaWVudElkIHx8IFwiXCIgfVxuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlV2l0aFJldHJ5KFwiZ2V0X21lc3NhZ2VzXCIsIHsgdHlwZSwgcm9vbUlkLCByZWNpcGllbnRJZCB9KVxuICB9XG5cbiAgYXN5bmMgZWRpdE1lc3NhZ2UobWVzc2FnZUlkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgcm9vbUlkPzogc3RyaW5nLCByZWNpcGllbnRJZD86IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlV2l0aFJldHJ5KFwiZWRpdF9tZXNzYWdlXCIsIHsgbWVzc2FnZUlkLCBjb250ZW50LCByb29tSWQsIHJlY2lwaWVudElkIH0pXG4gIH1cblxuICBhc3luYyBkZWxldGVNZXNzYWdlKG1lc3NhZ2VJZDogc3RyaW5nLCByb29tSWQ/OiBzdHJpbmcsIHJlY2lwaWVudElkPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2VXaXRoUmV0cnkoXCJkZWxldGVfbWVzc2FnZVwiLCB7IG1lc3NhZ2VJZCwgcm9vbUlkLCByZWNpcGllbnRJZCB9KVxuICB9XG5cbiAgYXN5bmMgZ2V0T25saW5lVXNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXCJnZXRfb25saW5lX3VzZXJzXCIsIHt9KSAvLyBEb24ndCByZXRyeSB0aGlzIGFzIGl0J3MgY2FsbGVkIGZyZXF1ZW50bHlcbiAgfVxuXG4gIGdldFBlcnNpc3RlZFJvb21zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlcnNpc3RlZFJvb21zKVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFBvbGxpbmcoKSB7XG4gICAgLy8gUG9sbCBmb3IgdXBkYXRlcyBldmVyeSAzIHNlY29uZHMgKGluY3JlYXNlZCBmcm9tIDJzIHRvIHJlZHVjZSBsb2FkKVxuICAgIHRoaXMucG9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2tpcHBpbmcgcG9sbCAtIG5vdCBjb25uZWN0ZWRcIilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCBsYXRlc3QgbWVzc2FnZXMgZm9yIGN1cnJlbnQgY29udGV4dFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q29udGV4dCkge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb250ZXh0LnR5cGUgPT09IFwicm9vbVwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlKFwiZ2V0X21lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyb29tXCIsXG4gICAgICAgICAgICAgIHJvb21JZDogdGhpcy5jdXJyZW50Q29udGV4dC5pZCxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQudHlwZSA9PT0gXCJyb29tX21lc3NhZ2VzXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicm9vbV9tZXNzYWdlc191cGRhdGVcIixcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5lcnJvcj8uaW5jbHVkZXMoXCJOZXR3b3JrXCIpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTmV0d29yayBlcnJvciBkdXJpbmcgcG9sbGluZywgd2lsbCByZXRyeSBvbiBuZXh0IGludGVydmFsXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRDb250ZXh0LnR5cGUgPT09IFwiZG1cIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShcImdldF9tZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG1cIixcbiAgICAgICAgICAgICAgcmVjaXBpZW50SWQ6IHRoaXMuY3VycmVudENvbnRleHQuaWQsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LnR5cGUgPT09IFwiZG1fbWVzc2FnZXNcIikge1xuICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkbV9tZXNzYWdlc191cGRhdGVcIixcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgb25saW5lIHVzZXJzIHBlcmlvZGljYWxseSAobGVzcyBmcmVxdWVudGx5KVxuICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMykge1xuICAgICAgICAgIC8vIE9ubHkgMzAlIG9mIHRoZSB0aW1lIHRvIHJlZHVjZSBsb2FkXG4gICAgICAgICAgYXdhaXQgdGhpcy5nZXRPbmxpbmVVc2VycygpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb2xsaW5nIGVycm9yOlwiLCBlcnJvcilcbiAgICAgICAgLy8gRG9uJ3QgbWFyayBhcyBkaXNjb25uZWN0ZWQgZm9yIHBvbGxpbmcgZXJyb3JzXG4gICAgICB9XG4gICAgfSwgMzAwMClcbiAgfVxuXG4gIGFzeW5jIHJlY29ubmVjdCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkF0dGVtcHRpbmcgdG8gcmVjb25uZWN0Li4uXCIpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSkgLy8gV2FpdCAxIHNlY29uZFxuICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpXG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIGNvbnNvbGUubG9nKFwiRGlzY29ubmVjdGluZyBXZWJTb2NrZXQgY2xpZW50Li4uXCIpXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgaWYgKHRoaXMucG9sbEludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMucG9sbEludGVydmFsKVxuICAgICAgdGhpcy5wb2xsSW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuICAgIHRoaXMuY3VycmVudFJvb20gPSBudWxsXG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uTWVzc2FnZSh7IHR5cGU6IFwiZGlzY29ubmVjdGVkXCIgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkRldlRlYVdlYlNvY2tldENsaWVudCIsImNvbm5lY3QiLCJjb25zb2xlIiwibG9nIiwiaXNDb25uZWN0ZWQiLCJyZXRyeUNvdW50IiwicmVzdWx0Iiwic2VuZE1lc3NhZ2VXaXRoUmV0cnkiLCJ1c2VySWQiLCJ1c2VybmFtZSIsInN1Y2Nlc3MiLCJkYXRhIiwiam9pbmVkUm9vbXMiLCJwZXJzaXN0ZWRSb29tcyIsIlNldCIsIkFycmF5IiwiZnJvbSIsInN0YXJ0UG9sbGluZyIsIm9uTWVzc2FnZSIsInR5cGUiLCJlcnJvciIsInNlbmRNZXNzYWdlIiwid2FybiIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJqc29uIiwibmFtZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIm1heFJldHJpZXMiLCJhdHRlbXB0IiwiZGVsYXkiLCJNYXRoIiwibWluIiwicG93IiwiUHJvbWlzZSIsInJlc29sdmUiLCJqb2luUm9vbSIsInJvb21JZCIsImN1cnJlbnRSb29tIiwiY3VycmVudENvbnRleHQiLCJpZCIsImFkZCIsImxlYXZlUm9vbSIsImRlbGV0ZSIsInNlYXJjaFJvb21zIiwicXVlcnkiLCJjcmVhdGVSb29tIiwiZGVzY3JpcHRpb24iLCJnZXRSb29tcyIsImdldEpvaW5lZFJvb21zIiwiZ2V0Um9vbU1lbWJlcnMiLCJzZW5kQ2hhdE1lc3NhZ2UiLCJjb250ZW50IiwicmVjaXBpZW50SWQiLCJtZXNzYWdlRGF0YSIsImdldE1lc3NhZ2VzIiwiZWRpdE1lc3NhZ2UiLCJtZXNzYWdlSWQiLCJkZWxldGVNZXNzYWdlIiwiZ2V0T25saW5lVXNlcnMiLCJnZXRQZXJzaXN0ZWRSb29tcyIsInBvbGxJbnRlcnZhbCIsInNldEludGVydmFsIiwicmFuZG9tIiwicmVjb25uZWN0IiwiZGlzY29ubmVjdCIsImNsZWFySW50ZXJ2YWwiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/websocket-client.ts\n"));

/***/ })

});