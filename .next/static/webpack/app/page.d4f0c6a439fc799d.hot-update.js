"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/websocket-client.ts":
/*!*********************************!*\
  !*** ./lib/websocket-client.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DevTeaWebSocketClient: function() { return /* binding */ DevTeaWebSocketClient; }\n/* harmony export */ });\nclass DevTeaWebSocketClient {\n    async connect() {\n        console.log(\"Connecting WebSocket client...\");\n        // Register user\n        const result = await this.sendMessage(\"register\", {\n            userId: this.userId,\n            username: this.username\n        });\n        if (result.success) {\n            var _result_data;\n            // Restore joined rooms from registration response\n            if ((_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.joinedRooms) {\n                this.persistedRooms = new Set(result.data.joinedRooms);\n                console.log(\"Restored rooms:\", Array.from(this.persistedRooms));\n            }\n            // Start polling for updates\n            this.startPolling();\n            this.onMessage({\n                type: \"connected\",\n                data: {\n                    joinedRooms: Array.from(this.persistedRooms)\n                }\n            });\n            console.log(\"WebSocket client connected successfully\");\n        } else {\n            console.error(\"Failed to register user\");\n        }\n    }\n    async sendMessage(type, data) {\n        try {\n            console.log(\"Sending message: \".concat(type), data);\n            const response = await fetch(\"/api/websocket\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    type,\n                    data,\n                    userId: this.userId\n                })\n            });\n            const result = await response.json();\n            console.log(\"Response for \".concat(type, \":\"), result);\n            if (result.success && result.type) {\n                this.onMessage(result);\n            }\n            return result;\n        } catch (error) {\n            console.error(\"WebSocket send error:\", error);\n            return {\n                success: false,\n                error\n            };\n        }\n    }\n    async joinRoom(roomId) {\n        console.log(\"Joining room: \".concat(roomId));\n        this.currentRoom = roomId;\n        this.currentContext = {\n            type: \"room\",\n            id: roomId\n        };\n        this.persistedRooms.add(roomId);\n        return this.sendMessage(\"join_room\", {\n            roomId\n        });\n    }\n    async leaveRoom(roomId) {\n        console.log(\"Leaving room: \".concat(roomId));\n        const result = await this.sendMessage(\"leave_room\", {\n            roomId\n        });\n        if (result.success) {\n            this.persistedRooms.delete(roomId);\n            if (this.currentRoom === roomId) {\n                this.currentRoom = null;\n                this.currentContext = null;\n            }\n        }\n        return result;\n    }\n    async searchRooms(query) {\n        return this.sendMessage(\"search_rooms\", {\n            query\n        });\n    }\n    async createRoom(name, description) {\n        var _result_data;\n        const result = await this.sendMessage(\"create_room\", {\n            name,\n            description\n        });\n        if (result.success && ((_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.id)) {\n            this.persistedRooms.add(result.data.id);\n        }\n        return result;\n    }\n    async getRooms() {\n        return this.sendMessage(\"get_rooms\", {});\n    }\n    async getJoinedRooms() {\n        return this.sendMessage(\"get_joined_rooms\", {});\n    }\n    async getRoomMembers(roomId) {\n        return this.sendMessage(\"get_room_members\", {\n            roomId\n        });\n    }\n    async sendChatMessage(content, type, roomId, recipientId) {\n        console.log(\"Sending chat message to \".concat(type, \":\"), {\n            content,\n            roomId,\n            recipientId\n        });\n        // Add this validation to ensure we're sending to the correct room\n        if (type === \"room\" && !roomId) {\n            console.error(\"Attempted to send room message without roomId\");\n            return {\n                success: false,\n                error: \"Missing roomId for room message\"\n            };\n        }\n        return this.sendMessage(\"send_message\", {\n            username: this.username,\n            content,\n            type,\n            roomId,\n            recipientId\n        });\n    }\n    async getMessages(type, roomId, recipientId) {\n        console.log(\"Getting messages for \".concat(type, \":\"), {\n            roomId,\n            recipientId\n        });\n        this.currentContext = {\n            type,\n            id: roomId || recipientId || \"\"\n        };\n        return this.sendMessage(\"get_messages\", {\n            type,\n            roomId,\n            recipientId\n        });\n    }\n    async editMessage(messageId, content, roomId, recipientId) {\n        return this.sendMessage(\"edit_message\", {\n            messageId,\n            content,\n            roomId,\n            recipientId\n        });\n    }\n    async deleteMessage(messageId, roomId, recipientId) {\n        return this.sendMessage(\"delete_message\", {\n            messageId,\n            roomId,\n            recipientId\n        });\n    }\n    async getOnlineUsers() {\n        return this.sendMessage(\"get_online_users\", {});\n    }\n    getPersistedRooms() {\n        return Array.from(this.persistedRooms);\n    }\n    startPolling() {\n        // Poll for updates every 2 seconds to simulate real-time\n        this.pollInterval = setInterval(async ()=>{\n            try {\n                // Get latest messages for current context\n                if (this.currentContext) {\n                    if (this.currentContext.type === \"room\") {\n                        const result = await this.sendMessage(\"get_messages\", {\n                            type: \"room\",\n                            roomId: this.currentContext.id\n                        });\n                        if (result.success && result.type === \"room_messages\") {\n                            this.onMessage({\n                                type: \"room_messages_update\",\n                                data: result.data\n                            });\n                        }\n                    } else if (this.currentContext.type === \"dm\") {\n                        const result = await this.sendMessage(\"get_messages\", {\n                            type: \"dm\",\n                            recipientId: this.currentContext.id\n                        });\n                        if (result.success && result.type === \"dm_messages\") {\n                            this.onMessage({\n                                type: \"dm_messages_update\",\n                                data: result.data\n                            });\n                        }\n                    }\n                }\n                // Get online users periodically\n                await this.getOnlineUsers();\n            } catch (error) {\n                console.error(\"Polling error:\", error);\n            }\n        }, 2000);\n    }\n    disconnect() {\n        console.log(\"Disconnecting WebSocket client...\");\n        if (this.pollInterval) {\n            clearInterval(this.pollInterval);\n            this.pollInterval = null;\n        }\n        this.currentRoom = null;\n        this.currentContext = null;\n        this.onMessage({\n            type: \"disconnected\"\n        });\n    }\n    constructor(userId, username, onMessage){\n        this.pollInterval = null;\n        this.currentRoom = null;\n        this.currentContext = null;\n        this.persistedRooms = new Set();\n        this.userId = userId;\n        this.username = username;\n        this.onMessage = onMessage;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi93ZWJzb2NrZXQtY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFvQk8sTUFBTUE7SUFlWCxNQUFNQyxVQUFVO1FBQ2RDLFFBQVFDLEdBQUcsQ0FBQztRQUNaLGdCQUFnQjtRQUNoQixNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUMsWUFBWTtZQUFFQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUFFQyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtRQUFDO1FBRWpHLElBQUlILE9BQU9JLE9BQU8sRUFBRTtnQkFFZEo7WUFESixrREFBa0Q7WUFDbEQsS0FBSUEsZUFBQUEsT0FBT0ssSUFBSSxjQUFYTCxtQ0FBQUEsYUFBYU0sV0FBVyxFQUFFO2dCQUM1QixJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJQyxJQUFJUixPQUFPSyxJQUFJLENBQUNDLFdBQVc7Z0JBQ3JEUixRQUFRQyxHQUFHLENBQUMsbUJBQW1CVSxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDSCxjQUFjO1lBQy9EO1lBRUEsNEJBQTRCO1lBQzVCLElBQUksQ0FBQ0ksWUFBWTtZQUNqQixJQUFJLENBQUNDLFNBQVMsQ0FBQztnQkFBRUMsTUFBTTtnQkFBYVIsTUFBTTtvQkFBRUMsYUFBYUcsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ0gsY0FBYztnQkFBRTtZQUFFO1lBQzNGVCxRQUFRQyxHQUFHLENBQUM7UUFDZCxPQUFPO1lBQ0xELFFBQVFnQixLQUFLLENBQUM7UUFDaEI7SUFDRjtJQUVBLE1BQU1iLFlBQVlZLElBQVksRUFBRVIsSUFBUyxFQUFFO1FBQ3pDLElBQUk7WUFDRlAsUUFBUUMsR0FBRyxDQUFDLG9CQUF5QixPQUFMYyxPQUFRUjtZQUN4QyxNQUFNVSxXQUFXLE1BQU1DLE1BQU0sa0JBQWtCO2dCQUM3Q0MsUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFUjtvQkFBTVI7b0JBQU1ILFFBQVEsSUFBSSxDQUFDQSxNQUFNO2dCQUFDO1lBQ3pEO1lBRUEsTUFBTUYsU0FBUyxNQUFNZSxTQUFTTyxJQUFJO1lBQ2xDeEIsUUFBUUMsR0FBRyxDQUFDLGdCQUFxQixPQUFMYyxNQUFLLE1BQUliO1lBRXJDLElBQUlBLE9BQU9JLE9BQU8sSUFBSUosT0FBT2EsSUFBSSxFQUFFO2dCQUNqQyxJQUFJLENBQUNELFNBQVMsQ0FBQ1o7WUFDakI7WUFFQSxPQUFPQTtRQUNULEVBQUUsT0FBT2MsT0FBTztZQUNkaEIsUUFBUWdCLEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDLE9BQU87Z0JBQUVWLFNBQVM7Z0JBQU9VO1lBQU07UUFDakM7SUFDRjtJQUVBLE1BQU1TLFNBQVNDLE1BQWMsRUFBRTtRQUM3QjFCLFFBQVFDLEdBQUcsQ0FBQyxpQkFBd0IsT0FBUHlCO1FBQzdCLElBQUksQ0FBQ0MsV0FBVyxHQUFHRDtRQUNuQixJQUFJLENBQUNFLGNBQWMsR0FBRztZQUFFYixNQUFNO1lBQVFjLElBQUlIO1FBQU87UUFDakQsSUFBSSxDQUFDakIsY0FBYyxDQUFDcUIsR0FBRyxDQUFDSjtRQUN4QixPQUFPLElBQUksQ0FBQ3ZCLFdBQVcsQ0FBQyxhQUFhO1lBQUV1QjtRQUFPO0lBQ2hEO0lBRUEsTUFBTUssVUFBVUwsTUFBYyxFQUFFO1FBQzlCMUIsUUFBUUMsR0FBRyxDQUFDLGlCQUF3QixPQUFQeUI7UUFDN0IsTUFBTXhCLFNBQVMsTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQyxjQUFjO1lBQUV1QjtRQUFPO1FBRTdELElBQUl4QixPQUFPSSxPQUFPLEVBQUU7WUFDbEIsSUFBSSxDQUFDRyxjQUFjLENBQUN1QixNQUFNLENBQUNOO1lBQzNCLElBQUksSUFBSSxDQUFDQyxXQUFXLEtBQUtELFFBQVE7Z0JBQy9CLElBQUksQ0FBQ0MsV0FBVyxHQUFHO2dCQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRztZQUN4QjtRQUNGO1FBRUEsT0FBTzFCO0lBQ1Q7SUFFQSxNQUFNK0IsWUFBWUMsS0FBYSxFQUFFO1FBQy9CLE9BQU8sSUFBSSxDQUFDL0IsV0FBVyxDQUFDLGdCQUFnQjtZQUFFK0I7UUFBTTtJQUNsRDtJQUVBLE1BQU1DLFdBQVdDLElBQVksRUFBRUMsV0FBbUIsRUFBRTtZQUU1Qm5DO1FBRHRCLE1BQU1BLFNBQVMsTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQyxlQUFlO1lBQUVpQztZQUFNQztRQUFZO1FBQ3pFLElBQUluQyxPQUFPSSxPQUFPLE1BQUlKLGVBQUFBLE9BQU9LLElBQUksY0FBWEwsbUNBQUFBLGFBQWEyQixFQUFFLEdBQUU7WUFDckMsSUFBSSxDQUFDcEIsY0FBYyxDQUFDcUIsR0FBRyxDQUFDNUIsT0FBT0ssSUFBSSxDQUFDc0IsRUFBRTtRQUN4QztRQUNBLE9BQU8zQjtJQUNUO0lBRUEsTUFBTW9DLFdBQVc7UUFDZixPQUFPLElBQUksQ0FBQ25DLFdBQVcsQ0FBQyxhQUFhLENBQUM7SUFDeEM7SUFFQSxNQUFNb0MsaUJBQWlCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDcEMsV0FBVyxDQUFDLG9CQUFvQixDQUFDO0lBQy9DO0lBRUEsTUFBTXFDLGVBQWVkLE1BQWMsRUFBRTtRQUNuQyxPQUFPLElBQUksQ0FBQ3ZCLFdBQVcsQ0FBQyxvQkFBb0I7WUFBRXVCO1FBQU87SUFDdkQ7SUFFQSxNQUFNZSxnQkFBZ0JDLE9BQWUsRUFBRTNCLElBQW1CLEVBQUVXLE1BQWUsRUFBRWlCLFdBQW9CLEVBQUU7UUFDakczQyxRQUFRQyxHQUFHLENBQUMsMkJBQWdDLE9BQUxjLE1BQUssTUFBSTtZQUFFMkI7WUFBU2hCO1lBQVFpQjtRQUFZO1FBRS9FLGtFQUFrRTtRQUNsRSxJQUFJNUIsU0FBUyxVQUFVLENBQUNXLFFBQVE7WUFDOUIxQixRQUFRZ0IsS0FBSyxDQUFDO1lBQ2QsT0FBTztnQkFBRVYsU0FBUztnQkFBT1UsT0FBTztZQUFrQztRQUNwRTtRQUVBLE9BQU8sSUFBSSxDQUFDYixXQUFXLENBQUMsZ0JBQWdCO1lBQ3RDRSxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QnFDO1lBQ0EzQjtZQUNBVztZQUNBaUI7UUFDRjtJQUNGO0lBRUEsTUFBTUMsWUFBWTdCLElBQW1CLEVBQUVXLE1BQWUsRUFBRWlCLFdBQW9CLEVBQUU7UUFDNUUzQyxRQUFRQyxHQUFHLENBQUMsd0JBQTZCLE9BQUxjLE1BQUssTUFBSTtZQUFFVztZQUFRaUI7UUFBWTtRQUNuRSxJQUFJLENBQUNmLGNBQWMsR0FBRztZQUFFYjtZQUFNYyxJQUFJSCxVQUFVaUIsZUFBZTtRQUFHO1FBQzlELE9BQU8sSUFBSSxDQUFDeEMsV0FBVyxDQUFDLGdCQUFnQjtZQUFFWTtZQUFNVztZQUFRaUI7UUFBWTtJQUN0RTtJQUVBLE1BQU1FLFlBQVlDLFNBQWlCLEVBQUVKLE9BQWUsRUFBRWhCLE1BQWUsRUFBRWlCLFdBQW9CLEVBQUU7UUFDM0YsT0FBTyxJQUFJLENBQUN4QyxXQUFXLENBQUMsZ0JBQWdCO1lBQUUyQztZQUFXSjtZQUFTaEI7WUFBUWlCO1FBQVk7SUFDcEY7SUFFQSxNQUFNSSxjQUFjRCxTQUFpQixFQUFFcEIsTUFBZSxFQUFFaUIsV0FBb0IsRUFBRTtRQUM1RSxPQUFPLElBQUksQ0FBQ3hDLFdBQVcsQ0FBQyxrQkFBa0I7WUFBRTJDO1lBQVdwQjtZQUFRaUI7UUFBWTtJQUM3RTtJQUVBLE1BQU1LLGlCQUFpQjtRQUNyQixPQUFPLElBQUksQ0FBQzdDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQztJQUMvQztJQUVBOEMsb0JBQThCO1FBQzVCLE9BQU90QyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDSCxjQUFjO0lBQ3ZDO0lBRVFJLGVBQWU7UUFDckIseURBQXlEO1FBQ3pELElBQUksQ0FBQ3FDLFlBQVksR0FBR0MsWUFBWTtZQUM5QixJQUFJO2dCQUNGLDBDQUEwQztnQkFDMUMsSUFBSSxJQUFJLENBQUN2QixjQUFjLEVBQUU7b0JBQ3ZCLElBQUksSUFBSSxDQUFDQSxjQUFjLENBQUNiLElBQUksS0FBSyxRQUFRO3dCQUN2QyxNQUFNYixTQUFTLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUMsZ0JBQWdCOzRCQUNwRFksTUFBTTs0QkFDTlcsUUFBUSxJQUFJLENBQUNFLGNBQWMsQ0FBQ0MsRUFBRTt3QkFDaEM7d0JBRUEsSUFBSTNCLE9BQU9JLE9BQU8sSUFBSUosT0FBT2EsSUFBSSxLQUFLLGlCQUFpQjs0QkFDckQsSUFBSSxDQUFDRCxTQUFTLENBQUM7Z0NBQ2JDLE1BQU07Z0NBQ05SLE1BQU1MLE9BQU9LLElBQUk7NEJBQ25CO3dCQUNGO29CQUNGLE9BQU8sSUFBSSxJQUFJLENBQUNxQixjQUFjLENBQUNiLElBQUksS0FBSyxNQUFNO3dCQUM1QyxNQUFNYixTQUFTLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUMsZ0JBQWdCOzRCQUNwRFksTUFBTTs0QkFDTjRCLGFBQWEsSUFBSSxDQUFDZixjQUFjLENBQUNDLEVBQUU7d0JBQ3JDO3dCQUVBLElBQUkzQixPQUFPSSxPQUFPLElBQUlKLE9BQU9hLElBQUksS0FBSyxlQUFlOzRCQUNuRCxJQUFJLENBQUNELFNBQVMsQ0FBQztnQ0FDYkMsTUFBTTtnQ0FDTlIsTUFBTUwsT0FBT0ssSUFBSTs0QkFDbkI7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsZ0NBQWdDO2dCQUNoQyxNQUFNLElBQUksQ0FBQ3lDLGNBQWM7WUFDM0IsRUFBRSxPQUFPaEMsT0FBTztnQkFDZGhCLFFBQVFnQixLQUFLLENBQUMsa0JBQWtCQTtZQUNsQztRQUNGLEdBQUc7SUFDTDtJQUVBb0MsYUFBYTtRQUNYcEQsUUFBUUMsR0FBRyxDQUFDO1FBQ1osSUFBSSxJQUFJLENBQUNpRCxZQUFZLEVBQUU7WUFDckJHLGNBQWMsSUFBSSxDQUFDSCxZQUFZO1lBQy9CLElBQUksQ0FBQ0EsWUFBWSxHQUFHO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDdkIsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2QsU0FBUyxDQUFDO1lBQUVDLE1BQU07UUFBZTtJQUN4QztJQTNMQXVDLFlBQVlsRCxNQUFjLEVBQUVDLFFBQWdCLEVBQUVTLFNBQWlDLENBQUU7YUFMekVvQyxlQUFzQzthQUN0Q3ZCLGNBQTZCO2FBQzdCQyxpQkFBNkQ7YUFDN0RuQixpQkFBOEIsSUFBSUM7UUFHeEMsSUFBSSxDQUFDTixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ1MsU0FBUyxHQUFHQTtJQUNuQjtBQXdMRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvd2Vic29ja2V0LWNsaWVudC50cz83MDVlIl0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBNZXNzYWdlIHtcbiAgaWQ6IHN0cmluZ1xuICB1c2VyOiBzdHJpbmdcbiAgY29udGVudDogc3RyaW5nXG4gIHRpbWVzdGFtcDogbnVtYmVyXG4gIGVkaXRlZD86IGJvb2xlYW5cbiAgcm9vbUlkPzogc3RyaW5nXG4gIHJlY2lwaWVudElkPzogc3RyaW5nXG4gIHR5cGU6IFwicm9vbVwiIHwgXCJkbVwiXG59XG5cbmludGVyZmFjZSBSb29tIHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBtZW1iZXJDb3VudDogbnVtYmVyXG4gIGlzTWVtYmVyOiBib29sZWFuXG4gIGlzSm9pbmVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBEZXZUZWFXZWJTb2NrZXRDbGllbnQge1xuICBwcml2YXRlIHVzZXJJZDogc3RyaW5nXG4gIHByaXZhdGUgdXNlcm5hbWU6IHN0cmluZ1xuICBwcml2YXRlIG9uTWVzc2FnZTogKG1lc3NhZ2U6IGFueSkgPT4gdm9pZFxuICBwcml2YXRlIHBvbGxJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGN1cnJlbnRSb29tOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGN1cnJlbnRDb250ZXh0OiB7IHR5cGU6IFwicm9vbVwiIHwgXCJkbVwiOyBpZDogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHBlcnNpc3RlZFJvb21zOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKVxuXG4gIGNvbnN0cnVjdG9yKHVzZXJJZDogc3RyaW5nLCB1c2VybmFtZTogc3RyaW5nLCBvbk1lc3NhZ2U6IChtZXNzYWdlOiBhbnkpID0+IHZvaWQpIHtcbiAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZFxuICAgIHRoaXMudXNlcm5hbWUgPSB1c2VybmFtZVxuICAgIHRoaXMub25NZXNzYWdlID0gb25NZXNzYWdlXG4gIH1cblxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGluZyBXZWJTb2NrZXQgY2xpZW50Li4uXCIpXG4gICAgLy8gUmVnaXN0ZXIgdXNlclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UoXCJyZWdpc3RlclwiLCB7IHVzZXJJZDogdGhpcy51c2VySWQsIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lIH0pXG5cbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFJlc3RvcmUgam9pbmVkIHJvb21zIGZyb20gcmVnaXN0cmF0aW9uIHJlc3BvbnNlXG4gICAgICBpZiAocmVzdWx0LmRhdGE/LmpvaW5lZFJvb21zKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVkUm9vbXMgPSBuZXcgU2V0KHJlc3VsdC5kYXRhLmpvaW5lZFJvb21zKVxuICAgICAgICBjb25zb2xlLmxvZyhcIlJlc3RvcmVkIHJvb21zOlwiLCBBcnJheS5mcm9tKHRoaXMucGVyc2lzdGVkUm9vbXMpKVxuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBwb2xsaW5nIGZvciB1cGRhdGVzXG4gICAgICB0aGlzLnN0YXJ0UG9sbGluZygpXG4gICAgICB0aGlzLm9uTWVzc2FnZSh7IHR5cGU6IFwiY29ubmVjdGVkXCIsIGRhdGE6IHsgam9pbmVkUm9vbXM6IEFycmF5LmZyb20odGhpcy5wZXJzaXN0ZWRSb29tcykgfSB9KVxuICAgICAgY29uc29sZS5sb2coXCJXZWJTb2NrZXQgY2xpZW50IGNvbm5lY3RlZCBzdWNjZXNzZnVsbHlcIilcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZWdpc3RlciB1c2VyXCIpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2VuZE1lc3NhZ2UodHlwZTogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFNlbmRpbmcgbWVzc2FnZTogJHt0eXBlfWAsIGRhdGEpXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS93ZWJzb2NrZXRcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgZGF0YSwgdXNlcklkOiB0aGlzLnVzZXJJZCB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc29sZS5sb2coYFJlc3BvbnNlIGZvciAke3R5cGV9OmAsIHJlc3VsdClcblxuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC50eXBlKSB7XG4gICAgICAgIHRoaXMub25NZXNzYWdlKHJlc3VsdClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiV2ViU29ja2V0IHNlbmQgZXJyb3I6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBqb2luUm9vbShyb29tSWQ6IHN0cmluZykge1xuICAgIGNvbnNvbGUubG9nKGBKb2luaW5nIHJvb206ICR7cm9vbUlkfWApXG4gICAgdGhpcy5jdXJyZW50Um9vbSA9IHJvb21JZFxuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSB7IHR5cGU6IFwicm9vbVwiLCBpZDogcm9vbUlkIH1cbiAgICB0aGlzLnBlcnNpc3RlZFJvb21zLmFkZChyb29tSWQpXG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXCJqb2luX3Jvb21cIiwgeyByb29tSWQgfSlcbiAgfVxuXG4gIGFzeW5jIGxlYXZlUm9vbShyb29tSWQ6IHN0cmluZykge1xuICAgIGNvbnNvbGUubG9nKGBMZWF2aW5nIHJvb206ICR7cm9vbUlkfWApXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShcImxlYXZlX3Jvb21cIiwgeyByb29tSWQgfSlcblxuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgdGhpcy5wZXJzaXN0ZWRSb29tcy5kZWxldGUocm9vbUlkKVxuICAgICAgaWYgKHRoaXMuY3VycmVudFJvb20gPT09IHJvb21JZCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRSb29tID0gbnVsbFxuICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGFzeW5jIHNlYXJjaFJvb21zKHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShcInNlYXJjaF9yb29tc1wiLCB7IHF1ZXJ5IH0pXG4gIH1cblxuICBhc3luYyBjcmVhdGVSb29tKG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UoXCJjcmVhdGVfcm9vbVwiLCB7IG5hbWUsIGRlc2NyaXB0aW9uIH0pXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhPy5pZCkge1xuICAgICAgdGhpcy5wZXJzaXN0ZWRSb29tcy5hZGQocmVzdWx0LmRhdGEuaWQpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGFzeW5jIGdldFJvb21zKCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKFwiZ2V0X3Jvb21zXCIsIHt9KVxuICB9XG5cbiAgYXN5bmMgZ2V0Sm9pbmVkUm9vbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXCJnZXRfam9pbmVkX3Jvb21zXCIsIHt9KVxuICB9XG5cbiAgYXN5bmMgZ2V0Um9vbU1lbWJlcnMocm9vbUlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShcImdldF9yb29tX21lbWJlcnNcIiwgeyByb29tSWQgfSlcbiAgfVxuXG4gIGFzeW5jIHNlbmRDaGF0TWVzc2FnZShjb250ZW50OiBzdHJpbmcsIHR5cGU6IFwicm9vbVwiIHwgXCJkbVwiLCByb29tSWQ/OiBzdHJpbmcsIHJlY2lwaWVudElkPzogc3RyaW5nKSB7XG4gICAgY29uc29sZS5sb2coYFNlbmRpbmcgY2hhdCBtZXNzYWdlIHRvICR7dHlwZX06YCwgeyBjb250ZW50LCByb29tSWQsIHJlY2lwaWVudElkIH0pXG5cbiAgICAvLyBBZGQgdGhpcyB2YWxpZGF0aW9uIHRvIGVuc3VyZSB3ZSdyZSBzZW5kaW5nIHRvIHRoZSBjb3JyZWN0IHJvb21cbiAgICBpZiAodHlwZSA9PT0gXCJyb29tXCIgJiYgIXJvb21JZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkF0dGVtcHRlZCB0byBzZW5kIHJvb20gbWVzc2FnZSB3aXRob3V0IHJvb21JZFwiKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIk1pc3Npbmcgcm9vbUlkIGZvciByb29tIG1lc3NhZ2VcIiB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXCJzZW5kX21lc3NhZ2VcIiwge1xuICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICBjb250ZW50LFxuICAgICAgdHlwZSxcbiAgICAgIHJvb21JZCxcbiAgICAgIHJlY2lwaWVudElkLFxuICAgIH0pXG4gIH1cblxuICBhc3luYyBnZXRNZXNzYWdlcyh0eXBlOiBcInJvb21cIiB8IFwiZG1cIiwgcm9vbUlkPzogc3RyaW5nLCByZWNpcGllbnRJZD86IHN0cmluZykge1xuICAgIGNvbnNvbGUubG9nKGBHZXR0aW5nIG1lc3NhZ2VzIGZvciAke3R5cGV9OmAsIHsgcm9vbUlkLCByZWNpcGllbnRJZCB9KVxuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSB7IHR5cGUsIGlkOiByb29tSWQgfHwgcmVjaXBpZW50SWQgfHwgXCJcIiB9XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXCJnZXRfbWVzc2FnZXNcIiwgeyB0eXBlLCByb29tSWQsIHJlY2lwaWVudElkIH0pXG4gIH1cblxuICBhc3luYyBlZGl0TWVzc2FnZShtZXNzYWdlSWQ6IHN0cmluZywgY29udGVudDogc3RyaW5nLCByb29tSWQ/OiBzdHJpbmcsIHJlY2lwaWVudElkPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXCJlZGl0X21lc3NhZ2VcIiwgeyBtZXNzYWdlSWQsIGNvbnRlbnQsIHJvb21JZCwgcmVjaXBpZW50SWQgfSlcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZU1lc3NhZ2UobWVzc2FnZUlkOiBzdHJpbmcsIHJvb21JZD86IHN0cmluZywgcmVjaXBpZW50SWQ/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShcImRlbGV0ZV9tZXNzYWdlXCIsIHsgbWVzc2FnZUlkLCByb29tSWQsIHJlY2lwaWVudElkIH0pXG4gIH1cblxuICBhc3luYyBnZXRPbmxpbmVVc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShcImdldF9vbmxpbmVfdXNlcnNcIiwge30pXG4gIH1cblxuICBnZXRQZXJzaXN0ZWRSb29tcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZXJzaXN0ZWRSb29tcylcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRQb2xsaW5nKCkge1xuICAgIC8vIFBvbGwgZm9yIHVwZGF0ZXMgZXZlcnkgMiBzZWNvbmRzIHRvIHNpbXVsYXRlIHJlYWwtdGltZVxuICAgIHRoaXMucG9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gR2V0IGxhdGVzdCBtZXNzYWdlcyBmb3IgY3VycmVudCBjb250ZXh0XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudENvbnRleHQudHlwZSA9PT0gXCJyb29tXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UoXCJnZXRfbWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICB0eXBlOiBcInJvb21cIixcbiAgICAgICAgICAgICAgcm9vbUlkOiB0aGlzLmN1cnJlbnRDb250ZXh0LmlkLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC50eXBlID09PSBcInJvb21fbWVzc2FnZXNcIikge1xuICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyb29tX21lc3NhZ2VzX3VwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50Q29udGV4dC50eXBlID09PSBcImRtXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UoXCJnZXRfbWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICB0eXBlOiBcImRtXCIsXG4gICAgICAgICAgICAgIHJlY2lwaWVudElkOiB0aGlzLmN1cnJlbnRDb250ZXh0LmlkLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC50eXBlID09PSBcImRtX21lc3NhZ2VzXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG1fbWVzc2FnZXNfdXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IG9ubGluZSB1c2VycyBwZXJpb2RpY2FsbHlcbiAgICAgICAgYXdhaXQgdGhpcy5nZXRPbmxpbmVVc2VycygpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUG9sbGluZyBlcnJvcjpcIiwgZXJyb3IpXG4gICAgICB9XG4gICAgfSwgMjAwMClcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgY29uc29sZS5sb2coXCJEaXNjb25uZWN0aW5nIFdlYlNvY2tldCBjbGllbnQuLi5cIilcbiAgICBpZiAodGhpcy5wb2xsSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wb2xsSW50ZXJ2YWwpXG4gICAgICB0aGlzLnBvbGxJbnRlcnZhbCA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50Um9vbSA9IG51bGxcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25NZXNzYWdlKHsgdHlwZTogXCJkaXNjb25uZWN0ZWRcIiB9KVxuICB9XG59XG4iXSwibmFtZXMiOlsiRGV2VGVhV2ViU29ja2V0Q2xpZW50IiwiY29ubmVjdCIsImNvbnNvbGUiLCJsb2ciLCJyZXN1bHQiLCJzZW5kTWVzc2FnZSIsInVzZXJJZCIsInVzZXJuYW1lIiwic3VjY2VzcyIsImRhdGEiLCJqb2luZWRSb29tcyIsInBlcnNpc3RlZFJvb21zIiwiU2V0IiwiQXJyYXkiLCJmcm9tIiwic3RhcnRQb2xsaW5nIiwib25NZXNzYWdlIiwidHlwZSIsImVycm9yIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImpzb24iLCJqb2luUm9vbSIsInJvb21JZCIsImN1cnJlbnRSb29tIiwiY3VycmVudENvbnRleHQiLCJpZCIsImFkZCIsImxlYXZlUm9vbSIsImRlbGV0ZSIsInNlYXJjaFJvb21zIiwicXVlcnkiLCJjcmVhdGVSb29tIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiZ2V0Um9vbXMiLCJnZXRKb2luZWRSb29tcyIsImdldFJvb21NZW1iZXJzIiwic2VuZENoYXRNZXNzYWdlIiwiY29udGVudCIsInJlY2lwaWVudElkIiwiZ2V0TWVzc2FnZXMiLCJlZGl0TWVzc2FnZSIsIm1lc3NhZ2VJZCIsImRlbGV0ZU1lc3NhZ2UiLCJnZXRPbmxpbmVVc2VycyIsImdldFBlcnNpc3RlZFJvb21zIiwicG9sbEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJkaXNjb25uZWN0IiwiY2xlYXJJbnRlcnZhbCIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/websocket-client.ts\n"));

/***/ })

});